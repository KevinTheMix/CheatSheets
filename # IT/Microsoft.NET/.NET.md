# .NET

## Quick Tips

* [.NET Architecture Guides](https://dotnet.microsoft.com/en-us/learn/dotnet/architecture-guides) = e-books
* (Legacy) register a particular installed version of .NET into IIS: `C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_regiis.exe -i`
* An app can be packaged either as _self-contained_ (larger as it includes runtime itself) or _framework-dependent_ (requires prinstalled .NET runtime, **mandatory for development purposes**)
  * See [Microsoft - Application publishing](https://docs.microsoft.com/en-us/dotnet/core/deploying)

## Glossary

* **.NET** (formerly **.NET Core**) = FOSS managed cross-platform (ie Windows, Linux and macOS) redesign & replacement of **.NET Framework**
  * It is a runtime for .NET applications based on libraries simplification and standardization efforts (through ECMA), especially efficient in a microservices, containerized environment
  * _.Net Core 3_ (2019) = introduces C# 8, and desktop technologies (UWP & WPF), prior to version 3, Core apps could run atop (target) either the .NET Core or good old .NET Framework runtime
  * _.Net Core 3.1_ (2019) = last version of _.NET Core_ under that denomination
  * _.NET 5_ (2020)
  * _.NET 6_ (2021)
  * _.NET 7_ (2022)
  * _.NET 8_ (2023)
  * _.NET 9_
  * _.NET 10_
* **.NET Foundation** = independant open-source community-driven non-profit organization to support .NET innovation ecosystem
* **.NET Framework** = main implementation of CLI until being superseded by the cross-platform **.NET** (Core)
  * [Wikipedia - Version history](https://en.wikipedia.org/wiki/.NET_Framework_version_history)
* **.NET Standard** = theoretical formal standard specification (of libraries) to which specific implementations can adhere (**.Net framework** or **.NET Core** at the time)
  * Created in order to establish greater uniformity, up until last version 2.1 (now superseded by **.NET 5**'s CLI **Standard Libraries**)
* **ASP.NET** (_.ascx_ = custom user control, _.ashx_ = lightweight UI-less control)
* **ASP.NET Core** = formerly **ASP.NET** (still carrying the _Core_ nametag for the time being)
  * **ASP.NET Core 3+** = now depend on **.NET (Core)** (and can no longer be used on earlier .NET Framework)
  * **ASP.NET Razor** = programming syntax (using C#/VB) used to create dynamic pages
  * MVC Controllers = in any folder (**Controllers** by convention), _can_ inherit from `Controller`, _must_ end with `_Controller`, returns data or a view (MVC) or HTTP methods (WebApi)
  * MVC Models = in any folder (**Models** by convention)
  * MVC Views = Razor page, _must_ be in **Views** folder, in a sub-folder with same name as associated Controller (eg `Views/Koko/Index.cshtml` linked with `KokoController`)
  * MVC Helpers eg `Html.ActionLink("Go to koko", "Index", "Koko", new {...} )` = creates link to `Index()` method of _Koko_ Controller with optionally provided parameters
* **Blazor** = FOSS web framework used to create interactive web UI (using C# and HTML)
* **CIL** (Common Intermediate Language) = bytecode intermediary language
* **CLI** (Common Language Infrastructure) = ECMA open standard originated by Microsoft to describe multiple high-level languages running on different platforms (eg .NET (Framework), Mono)
* **COM** (Component Object Model) = Microsoft mechanism for creating reusable, language-independent software components
* **EventSource** (_System.Diagnostics.Tracing_) = base class for creating events for tracing across platforms
* **Global Assembly Cache** (GAC) = local machine central repository of shared assemblies, registered with a strong name (unique with a public key & version number, to prevent conflicts aka DLL hell)
  * View via `Windows + R` > _C:\Windows\assembly\gac\_msil_, configure via `gacutil.exe` CLI, PowerShell or .NET APIs (also see `sn.exe` to create strong names key pairs as _.snk_ or _.pfx_)
* **Object Linking and Embedding** (OLE) = Microsoft proprietary technology for embedding/linking documents & other objects, with for developers OLE Control Extension (OCX)
* **Standard Libraries** = set of libraries included in the CLI encapsulating common functions such as file read/writing, XML manipulation, exception handling, network communication, threading, reflection

### Associated Frameworks

* **.NET MAUI** = neo **Xamarin.Forms** merged into .NET 6, executes Android, iOS, macOS & Windows via .NET for those platforms
* **Aspire** = developer-focused orchestration & observability layer for modern .NET distributed microservices applications, with startup DI-powered string-based name resolution discoverability
* **Avalonia UI** = open-source pixel-perfect multi-platform .NET apps (Windows, macOS, Linux, iOs, Android, Wasm) based on WPF, part of .NET Foundation
* **MEF** (Microsoft Extensibility Framework) = framework for creating lightweight extensible applications (namespace of MEF nuget is `System.Composition`)
  * It is a configurable (via config file/`[attribute]` metadata) decentralized (no single container: plugin-based via IO implementation) DI engine with runtime DLL discoverability
  * It does DI, but also much more (extensibility, discoverability, plugins, contract-based anonimity, attributes filtering)
  * [The principle purpose of MEF is extensibility](https://stackoverflow.com/a/139847)
* **Microsoft XNA** = set of free tools & runtime environment developed by _Microsoft Gaming_ to facilitate video game development
* **Mono** = FOSS cross-platform implementation of .NET (sponsored by _Microsoft_, now largely superseded by .NET itself)
* **PowerBuilder** = _SAP_-owned programming language & IDE for developing (`DataWindow`-based) C#.NET compatible applications performing (primarily) CRUD DB operations
* **Prism** = framework for building loosely coupled, maintainable, and testable XAML applications in WPF, and Xamarin Forms
  * MvvM + [Event Aggregator](https://prismlibrary.com/docs/event-aggregator.html) + Region Manager (à la ASP Master Page) + Navigation (from/to) via `INavigationAware` methods
  * DI via either **MEF** or Unity
  * [Prism - Using the ViewModelLocator](https://www.youtube.com/watch?v=I_3LxBdvJi4) (naming convention-based)
* **Uno Platform** = open-source cross-platform pixel-perfect GUI based on WinUI & UWP (ie C# & XAML), released in 2018 not by Microsoft, smaller user base & 3rd party support, high code reuse
* **Windows Communication Foundation** (WCF) = obsolete service endpoints based communication framework (Microsoft now suggests using **gRPC**)
  * **WcfTestClient** = test web service APIs (_C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\WcfTestClient.exe_)
  * `using (OperationContextScope service = new OperationContextScope((IContextChannel)this.service))` where service is a referenced service contract
  * Providing an endpoint name in code will override the service client configuration generated by Visual Studio when the service reference was added with the corresponding endpoint configuration from _web.config_
    * `var service = new RemoteWebServiceClient("MyEndpoint");` will use the alternate configuration defined in web.config and not the service reference parameters
* **Windows RT** = a deprecated Windows 8 OS for mobile
* **Windows Workflow Foundation** (WF) = workflow engine for long-running processes (created in 2006)
* **WinRT** (Windows Runtime) = platform-agnostic component & application architecture implemented in C++
* **WinUI** = a user interface API (part of WinRT) based on XAML for previous Windows OS (up to Windows 10)

## API

These can also be run from Visual Studio:

* `dotnet --help`
* `dotnet new console -n "Project Name"` = new project of type _console_
* `dotnet new mstest`
* `dotnet run` = runs current project (as a DLL, not an _exe_, since it's _platform independant_)
* `dotnet test` = runs a test project
* `dotnet add package Newtonsoft.json --version 11.0.2`
* `dotnet build`
* `dotnet pack` = builds nuget (as defined in _.csproj_) into `bin\Debug`
* `dotnet publish` = publishes to current platform (transforms multi-platform independant DLL into platform specific _exe_-like in _bin\Debug_)
* `dotnet publish -r(untime) {RID}` = publishes to target platform (where RID is Runtime Identifier eg `win-x64`)

* **ilasm** & **ildasm** (aka Intermediate Language Assembler/Disassembler) = convert IL from/into DLL
  * Can be used to sign a DLL (by 'uncompiling' it first): `ildasm koko.dll /out:koko.il` then reassembling it with the necessary key `ilasm koko.il /res:koko.res /dll /key:koko.snk /out:koko.dll`

### DI

* `AddTransient()` = shared/recreated each time
* `AddSingleton()` = single instance passed around
* `services.Configure<MyOptions>(this.Configuration.GetSection(""))` = read configuration section

## Extensions

### Nugets

* **Chocolatey** = machine-level CLI package manager using NuGet package infrastructure and PowerShell to download/install (2011)
* **ProGet** = freemium Linux/Windows package management system, primarily for NuGet (but supports other package managers: npm, RubyGems, PowerShell, Visual Studio Extensions)

* **AutoMapper** = DLL-discovery-based layer entities mapper
* **CefSharp** = open-source embedded web browser for WinForms/WPF apps (based on _CEF_ aka _Chromium Embedded Framework_, w/ headless version for automation projects)
* [CsGL](https://csgl.sourceforge.net) = C# graphics library (discontinued)
* **Dapper** = simple (EF/ORM) object mapper for .NET
* **ExpertComponents Toolkit Total** = .NET PDF & Excel creation (_$700+_)
* **Fluent Validation** = strongly-typed validation rules
* **Hangfire** = recurrent & persistent jobs
* **Html Agility Pack** = C# HTML parser/reader library
* **JsonSharp** = convert JSON to C# Object Initializer Syntax (similar online tools exist)
* **MassTransit** = scalable, secure, reliable popular messaging framework
* **MediatR** = Mediator Pattern implementation in .NET (ie both C/Q requests are classes deriving `IRequest<T>` & treated by `Handle(KokoRequest, CancellationToken)` handlers)
  * **Pipeline Behaviors** = run before and/or after a request handler (à la ASP.NET Core middleware but scoped to MediatR, not high-level HTTP requests) to address cross-cutting concerns elegantly (eg logging, exception handling)
  * See [CQRS with MediatR and Command Validation](https://dev.to/adrianbailador/implementing-cqrs-with-mediatr-in-net-8-a-complete-guide-1kof)
* **Moq** = popular .NET mocking framework
* **NHibernate** = open-source ORM (_actively developed_)
  * **Fluent NHibernate** = fluent XML-less compile safe automated convention-based mappings for NHibernate
* **Ninject** = DI engine
* **Noda** = date/time API (nuget)
* **NPOI** = .NET library for read/writing Microsoft Office binary & OOXML file formats
* **Npoi.Mapper** = convention-based _Excel_ mapper for NPOI
* **NServiceBus** (_Particular Software_) = infrastructure (eg messaging, storage) framework for building/monitoring/debugging distributed microservices-based applications
  * Does not handle actual transport (requires Amazon SQS, Azure Service Bus, MSMQ, RabbitMQ or SQL Server for message store)
* **NSwag** = open-source Swagger library/toolchain for .NET, ASP.NET Core & TypeScript
* **Nswag.MSBuild** = nuget package to integrate NSWag API client/server code generation into the MSBuild system, enabling automating code generation during the build process
* **Rx.NET** (_ReactiveX_) = Observer pattern applied to async streams as iterables (debounce & co)
  * See [ReactiveX](https://reactivex.io) = cross-platform asynchronous programming (eg debounce) with observable streams API (for eg .NET, Java, JavaScript)
* **Serilog** (Serialized log) = simple diagnostic logging to files/console/elsewhere, extending .NET format strings with a simple message templates DSL
* **Simple Injector** = FOSS simple DI library for aging .NET frameworks (.NET 5, .NET Standard, UWP, Mono, Xamarin)
* **Specflow** = FOSS behavior-driven development (BDD) framework (both a nuget & Visual Studio extension)
* [System.IO.Abstractions](https://www.nuget.org/packages/System.IO.Abstractions) = like `System.IO.File` but via injectable instance (instead of static) & mock-able
* **Topshelf** = enables to run an application as either a console or (Windows) service - for ease of debugging
* **xUnit.net** = automated testing software framework/label/architecture composed of defined components: test cases & suites (ie groups), assertions, fixtures (environment), runner to report results
  * Notably used by Microsoft (in place of their self-developed _mstest_)
* **YARP** (Yet Another Reverse Proxy) = reverse proxy server

### 3rd-Party Services/Utilities

* **.Net Fiddle** = online .NET (C#, F#, VB) playground/sandbox
* **.NET Reflector** = .NET decompiler (_$94_)
* **dotPeek** (_JetBrains_) = .NET decompiler
* **ILSpy** = .NET assembly decompiler
* **JustDecompile** (_Telerik_) = .NET assembly decompiler
* **LINQPad** = freemium utility to instantly test C# snipped or interactively query databases using LINQ (without an IDE)
* **NSwagStudio** = desktop GUI that generates client code & documentation from an Swagger OpenAPI Specification
* **Seq** = real-time search/analysis server for structured logs & traces, basically a JSON events viewer UI with search/alerting capabilities
* **Sharplab** = online .NET (C#, F#, **IL**, VB) playground/sandbox

## TODO

* [Create cloud-native apps and services with .NET and ASP.NET Core](https://learn.microsoft.com/en-us/training/paths/create-microservices-with-dotnet)
