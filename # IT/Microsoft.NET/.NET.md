# .NET

## Quick Tips

* [.NET Architecture Guides](https://dotnet.microsoft.com/en-us/learn/dotnet/architecture-guides) = e-books
* (Legacy) register a particular installed version of .NET into IIS: `C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_regiis.exe -i`
* An app can be packaged either as _self-contained_ (larger as it includes runtime itself) or _framework-dependent_ (requires prinstalled .NET runtime, **mandatory for development purposes**)
  * See [Microsoft - Application publishing](https://docs.microsoft.com/en-us/dotnet/core/deploying)

## Glossary

* **.NET** (formerly **.NET Core**) = FOSS managed cross-platform (ie Windows/Linux/macOS) redesign & replacement of **.NET Framework**
  * It is a runtime for .NET applications based on libraries simplification & standardization efforts (through ECMA), especially efficient in a microservices, containerized environment
* **.NET Foundation** = independant open-source community-driven non-profit organization to support .NET innovation ecosystem
* **.NET Framework** = main implementation of CLI until being superseded by the cross-platform **.NET** (Core)
  * [Wikipedia - Version history](https://en.wikipedia.org/wiki/.NET_Framework_version_history)
* **.NET Standard** = theoretical formal standard specification (of libraries) to which specific implementations can adhere (**.Net framework** or **.NET Core** at the time)
  * Created in order to establish greater uniformity, up until last version 2.1 (now superseded by **.NET 5**'s CLI **Standard Libraries**)
* **ASP.NET Core** (formerly **ASP.NET**) = umbrella framework for anything HTTP-related in .NET, essentially .NET plus additional libraries for web applications (eg Kestrel, MVC, Razor, HTTP-related components)
  * **Blazor** = FOSS interactive web component-based UI framework (server or WebAssembly, using C# and HTML)
  * **Minimal APIs** = lightweight/microservices HTTP APIs with minimal code in ASP.NET Core (one file per endpoint)
  * **MVC/Razor Pages** = programming syntax (using C#/VB) used to create dynamic pages
    * MVC Controllers = in any folder (**Controllers** by convention), _can_ inherit from `Controller`, _must_ end with `_Controller`, returns data or a view (MVC) or HTTP methods (WebApi)
    * MVC Models = in any folder (**Models** by convention)
    * MVC Views = Razor page, _must_ be in **Views** folder, in a sub-folder with same name as associated Controller (eg `Views/Koko/Index.cshtml` linked with `KokoController`)
    * MVC Helpers eg `Html.ActionLink("Go to koko", "Index", "Koko", new {...} )` = creates link to `Index()` method of _Koko_ Controller with optionally provided parameters
  * **Web API** = HTTP API returning JSON/XML
* **ASP.NET MVC** = late 2000s with Razor syntax (MVC à la Ruby on Rails)
* **ASP.NET Web Forms** = early 2000s desktop-like web technology with messy hidden HTML element for ViewState (_.aspx_, _.ascx_ custom user control, _.ashx_ lightweight UI-less control)
* **Common Intermediate Language** (CIL) = bytecode intermediary language
* **Common Language Infrastructure** (CLI) = ECMA open standard originated by Microsoft to describe multiple high-level languages running on different platforms (eg .NET (Framework), Mono)
* **Component Object Model** (COM) = Microsoft mechanism for creating reusable, language-independent software components
* **EventSource** (_System.Diagnostics.Tracing_) = base class for creating events for tracing across platforms
* **Global Assembly Cache** (GAC) = local machine central repository of shared assemblies, registered with a strong name (unique with a public key & version number, to prevent conflicts aka DLL hell)
  * View via `Windows + R` > _C:\Windows\assembly\gac\_msil_, configure via `gacutil.exe` CLI, PowerShell or .NET APIs (also see `sn.exe` to create strong names key pairs as _.snk_ or _.pfx_)
* **Kestrel** = recommended cross-platform high performance lightweight secure (HTTPS) default web server for ASP.NET Core projects (in place of IIS)
* **Object Linking and Embedding** (OLE) = Microsoft proprietary technology for embedding/linking documents & other objects, with for developers OLE Control Extension (OCX)
* **Standard Libraries** = set of libraries included in the CLI encapsulating common functions such as file read/writing, XML manipulation, exception handling, network communication, threading, reflection

### Versions

* 2002.02 **.NET 1.0**
* 2003.04 **.NET 1.1**
* 2005.11 **.NET 2.0**
* 2006.11 **.NET 3.0**
* 2007.11 **.NET 3.5**
* 2010.04 **.NET 4.0**
* 2012.08 **.NET 4.5**
* 2015.07 **.NET 4.6**
* 2016.06 **.NET Core 1.0**
* 2016.11 **.NET Core 1.1**
* 2017.05 **.NET 4.7**
* 2017.08 **.NET Core 2.0**
* 2018.05 **.NET Core 2.1**
* 2018.12 **.NET Core 2.2**
* 2019.04 **.NET 4.8**
* 2019.09 **.Net Core 3.0** = introduces C# 8, and desktop technologies (UWP & WPF), prior to version 3, Core apps could run atop (target) either the .NET Core or good old .NET Framework runtime
* 2019.12 **.Net Core 3.1** = last version of _.NET Core_ under that denomination
* 2020.11 **.NET 5** (C# 9)
* 2021.11 **.NET 6** (C# 10) = Minimal APIs for ASP.NET Core
* 2022.11 **.NET 7** (C# 11)
* 2023.11 **.NET 8** (C# 12)
* 2024.11 **.NET 9** (C# 13)
* 2025.11 **.NET 10** (C# 14) = leverages AVX-521 & ARM SVE vector extensions (15-30% performance improvements with no code change)

### Associated Frameworks

* **.NET MAUI** = neo **Xamarin.Forms** merged into .NET 6, executes Android, iOS, macOS & Windows via .NET for those platforms
* **Aspire** = 2023 opinionated healthcheck/observable/orchestration/telemetry framework for cloud-native distributed microservice applications (DI-powered string-based name resolution discoverability at startup, a dashboard)
  * **ServiceDefaults** = conventional shared infrastructure project that configures common cross-cutting concerns like OpenTelemetry, health checks, resilience patterns (eg Polly for retries/circuit breakers)
* **Avalonia UI** = open-source pixel-perfect multi-platform .NET apps (Windows, macOS, Linux, iOs, Android, Wasm) based on WPF, part of .NET Foundation
* **MEF** (Microsoft Extensibility Framework) = framework for creating lightweight extensible applications (namespace of MEF nuget is `System.Composition`)
  * It is a configurable (via config file/`[attribute]` metadata) decentralized (no single container: plugin-based via IO implementation) DI engine with runtime DLL discoverability
  * It does DI, but also much more (extensibility, discoverability, plugins, contract-based anonimity, attributes filtering)
  * [The principle purpose of MEF is extensibility](https://stackoverflow.com/a/139847)
* **Microsoft XNA** = set of free tools & runtime environment developed by _Microsoft Gaming_ to facilitate video game development
* **Mono** = FOSS cross-platform implementation of .NET (sponsored by _Microsoft_, now largely superseded by .NET itself)
* **PowerBuilder** = _SAP_-owned programming language & IDE for developing (`DataWindow`-based) C#.NET compatible applications performing (primarily) CRUD DB operations
* **Prism** = framework for building loosely coupled, maintainable, and testable XAML applications in WPF, and Xamarin Forms
  * MvvM + [Event Aggregator](https://prismlibrary.com/docs/event-aggregator.html) + Region Manager (à la ASP Master Page) + Navigation (from/to) via `INavigationAware` methods
  * DI via either **MEF** or Unity
  * [Prism - Using the ViewModelLocator](https://www.youtube.com/watch?v=I_3LxBdvJi4) (naming convention-based)
* **Uno Platform** = open-source cross-platform pixel-perfect GUI based on WinUI & UWP (ie C# & XAML), released in 2018 not by Microsoft, smaller user base & 3rd party support, high code reuse
* **Windows Communication Foundation** (WCF) = obsolete service endpoints based communication framework (Microsoft now suggests using **gRPC**)
  * **WcfTestClient** = test web service APIs (_C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\WcfTestClient.exe_)
  * `using (OperationContextScope service = new OperationContextScope((IContextChannel)this.service))` where service is a referenced service contract
  * Providing an endpoint name in code will override the service client configuration generated by Visual Studio when the service reference was added with the corresponding endpoint configuration from _web.config_
    * `var service = new RemoteWebServiceClient("MyEndpoint");` will use the alternate configuration defined in web.config and not the service reference parameters
* **Windows RT** = a deprecated Windows 8 OS for mobile
* **Windows Workflow Foundation** (WF) = workflow engine for long-running processes (created in 2006)
* **WinRT** (Windows Runtime) = platform-agnostic component & application architecture implemented in C++
* **WinUI** = a user interface API (part of WinRT) based on XAML for previous Windows OS (up to Windows 10)

## API

These can also be run from Visual Studio:

* `dotnet --help`
* `dotnet add package {nuget} (--version {version})` = install nuget (eg _Newtonsoft.json_)
* `dotnet build` = create a new project
* `dotnet ef` = entity framework management
  * `migrations add {migration_name}` = create a new migration by comparing current C# model classes (entities) against DB schema, generating changes needed to update DB
  * `database update` = applies all pending migrations to DB (create it if it does not exist)
* `dotnet new` = adds a new project
  * `-n "<project_name>"`
  * `console` = new project of type _console_
  * `(un)install` = (un)installs a template package that can then be used via `dotnet new <template>` to scaffold files/projects (templates can come from NuGet packages, local _.nupkg_ files, or folder paths)
  * `list` = lists installed template packages
  * `mstest`
* `dotnet pack` = builds nuget (as defined in _.csproj_) into `bin\Debug`
* `dotnet publish` = publishes to current platform (transforms multi-platform independant DLL into platform specific _exe_-like in _bin\Debug_)
  * `-r(untime) {RID}` = publishes to target platform (where RID is Runtime Identifier eg `win-x64`)
* `dotnet run` = runs current project (as a DLL, not an _exe_, since it's _platform independant_)
* `dotnet test` = runs a test project

* **ilasm** & **ildasm** (aka Intermediate Language Assembler/Disassembler) = convert IL from/into DLL
  * Can be used to sign a DLL (by 'uncompiling' it first): `ildasm koko.dll /out:koko.il` then reassembling it with the necessary key `ilasm koko.il /res:koko.res /dll /key:koko.snk /out:koko.dll`

### DI

* `AddTransient()` = shared/recreated each time
* `AddSingleton()` = single instance passed around
* `services.Configure<MyOptions>(this.Configuration.GetSection(""))` = read configuration section

## Extensions

* **NSwag** = open-source Swagger library/toolchain for .NET, ASP.NET Core & TypeScript

### Nugets

* **Chocolatey** = machine-level CLI package manager using NuGet package infrastructure and PowerShell to download/install (2011)
* **ProGet** = freemium Linux/Windows package management system, primarily for NuGet (but supports other package managers: npm, RubyGems, PowerShell, Visual Studio Extensions)

* **ArchUnit.Net** = C# architecture unit test library (eg `var domainTypes = …; var infrastructureTypes = …; var rule = domainTypes.Should().NotDependOnAny(infrastructureTypes); rule.Check(Architecture)`)
* **Aspose** (Cells, PDf, Words, etc) = documents & sheets manipulation in .NET
* **AutoMapper** = DLL-discovery-based layer entities mapper
* **CefSharp** = open-source embedded web browser for WinForms/WPF apps (based on _CEF_ aka _Chromium Embedded Framework_, w/ headless version for automation projects)
* [CsGL](https://csgl.sourceforge.net) = C# graphics library (discontinued)
* **Dapper** = simple ORM (object-relational mapper) for .NET, often used in combination with EF (Dapper reads/projects data into DTOs, EF tracks changes/navigation properties/unit of work)
* **ExpertComponents Toolkit Total** = .NET PDF & Excel creation (_$700+_)
* **Fluent Validation** = strongly-typed validation rules
* **Hangfire** = recurrent & persistent jobs
* **Html Agility Pack** = C# HTML parser/reader library
* **JsonSharp** = convert JSON to C# Object Initializer Syntax (similar online tools exist)
* **MassTransit** = open-source popular/reliable/scalable/secure messaging framework, infrastructure abstraction layer on top of message brokers (à la EF for DB, à la OpenTelemetry for observability)
* **MediatR** = mediator pattern implementation based on a couple of interfaces
  * `INotification` = one publisher to 0-many handlers/listeners with no response (à la event aggregator)
  * `IRequest` = CQRS commands & queries treated by `Handle(KokoRequest, CancellationToken)` handlers, queries have a response (pure commands do not)
  * **Pipeline Behaviors** = run before/after request handler (scoped to MediatR, not high-level ASP.NET Core HTTP requests) to address cross-cutting middleware concerns elegantly (eg logging, exception handling)
  * See [CQRS with MediatR and Command Validation](https://dev.to/adrianbailador/implementing-cqrs-with-mediatr-in-net-8-a-complete-guide-1kof)
* **Moq** = popular .NET mocking framework
* **NHibernate** = open-source ORM (_actively developed_)
  * **Fluent NHibernate** = fluent XML-less compile safe automated convention-based mappings for NHibernate
* **Ninject** = DI engine
* **Noda** = date/time API (nuget)
* **NPOI** = .NET library for read/writing Microsoft Office binary & OOXML file formats
* **Npoi.Mapper** = convention-based _Excel_ mapper for NPOI
* **NServiceBus** (_Particular Software_) = .NET library that abstracts messaging (transport/storage) between distributed services via transport-agnostic code
  * **Endpoint** = service with a logical name that send/receive/publishes messages
  * **Handler** = class that processes incoming messages, one per message type, auto-invoked when messages arrive
  * **Message** = either a Command (do X, one recipient) or an Event (X has happened, broadcasted to all listeners)
  * **Recoverability** = automatic retries, error queues, dead-letter handling when things fail
  * **Saga** = stateful handler for long-running workflows that span multiple messages
  * **Transport** = underlying message broker technology (eg RabbitMQ, MSMQ, Azure Service Bus, Amazon SQS, SQL Server for message store, etc) performing actual transport
* **Nswag.MSBuild** = nuget package to integrate NSWag API client/server code generation into MSBuild system, enabling automating code generation during build process
* **Ocelot** = lightweight .NET Core-based API gateway (ie unified entry point into microservices architecture)
* **OpenTelemetry** = packages for specific instrumentation & exporters (ASP.NET Core, automatic HTTP request tracing, SQL DB calls, send data somewhere)
* **Polly** = handles transient faults & improves app resilience via configurable strategies (retry, circuit breaker, hedging, timeout, rate limiter, fallback) to handle failures/slowdowns in a fluent & thread-safe way
* **Rx.NET** (_ReactiveX_) = Observer pattern applied to async streams as iterables (debounce & co)
  * See [ReactiveX](https://reactivex.io) = cross-platform asynchronous programming (eg debounce) with observable streams API (for eg .NET, Java, JavaScript)
* **Serilog** (Serialized log) = simple diagnostic logging to files/console/elsewhere, extending .NET format strings with a simple message templates DSL
* **Shiny Mediator** = mediator pattern implementation, but for built with ALL .NET apps in mind
* **Simple Injector** = FOSS simple DI library for aging .NET frameworks (.NET 5, .NET Standard, UWP, Mono, Xamarin)
* **Specflow** = FOSS behavior-driven development (BDD) framework (both a nuget & Visual Studio extension)
* [System.IO.Abstractions](https://www.nuget.org/packages/System.IO.Abstractions) = like `System.IO.File` but via injectable instance (instead of static) & mock-able
* **Topshelf** = enables to run an application as either a console or (Windows) service - for ease of debugging
* **Vogen** = value objects generator & code analyzer
* **xUnit.net** = automated testing software framework/label/architecture composed of defined components: test cases & suites (ie groups), assertions, fixtures (environment), runner to report results
  * Notably used by Microsoft (in place of their self-developed _mstest_)
* **YARP** (Yet Another Reverse Proxy) = reverse proxying & load balancing, routes requests based on paths/headers/custom logic

### 3rd-Party Services/Utilities

* **.Net Fiddle** = online .NET (C#, F#, VB) playground/sandbox
* **.NET Reflector** = .NET decompiler (_$94_)
* **dotPeek** (_JetBrains_) = .NET decompiler
* **ILSpy** = .NET assembly decompiler
* **JustDecompile** (_Telerik_) = .NET assembly decompiler
* **LINQPad** = freemium utility to instantly test C# snipped or interactively query databases using LINQ (without an IDE)
* **NSwagStudio** = desktop GUI that generates client code & documentation from an Swagger OpenAPI Specification
* **Seq** = real-time search/analysis server for structured logs & traces, basically a JSON events viewer UI with search/alerting capabilities
* **Sharplab** = online .NET (C#, F#, **IL**, VB) playground/sandbox

## TODO

* [Create cloud-native apps and services with .NET and ASP.NET Core](https://learn.microsoft.com/en-us/training/paths/create-microservices-with-dotnet)
