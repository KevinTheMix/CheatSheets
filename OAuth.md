# [OAuth 2.0](https://app.pluralsight.com/library/courses/oauth-2-getting-started/table-of-contents)

OAuth 2.0 is an API **Authorization** framework built for HTTP APIs, which provides **Scoped** (i.e. partial) access to an API, via **delegation** (the app dialogs with the API on behalf of the user) - not _impersonation_.

Past = XML + SOAP + SAML/WS-* (federation)
Now = JSON + HTTP APIs + OAuth & OpenID Connect
  
## History

The problem of API authorization.
Past solutions, and why they are no longer suitable for modern applications:

* Credential-sharing = the user provides her login/password to an application so it can access some resource (service).
  * Can't distinguish between user & application (**impersonation**).
  * Can't grant granular permissions: the application can do everything the user can.
  * Gives the application full access to user administration, enabling it to possibly change her password for malicious intents
  * If the app gets compromised, the user's password can get lost in nature. The user has then to change her password herself (no **revocation**).
  * If the app stores the login for user convenience, it can't just store it as a hash, since it needs to login into the resource each time the session must be reopened.
    * Thus they have to be stored in plain-text (or encrypted but reversibly so).
    * This also prevents using 2FA because it has to be repeatable by the app.
  * Federation is not possible (which is login once to multiple apps/websites e.g. Google apps, or company systems).
  * Prevents client-side-only SPA websites, who cannot possibly store credentials securely.
* Cookies = Redirects user to the API where she can login, which produces a cookie that the app can then use to access the API.
  * Better that providing login directly to the App in plain-text, and allows some granularity on the functionalities to allow.
  * But... CSRF; not only is the App authorized, but actually the whole browser is, since cookies are shared at the browser-level.
* API keys = store in the App a (long term) API key provided by the API.
  * Solve nearly all the above problems
  * But still doesn't work for applications that cannot keep a secret (client-side-only SPAs)
  * Besides, there is no standard, so you're on your own

## Misunderstandings

* OAuth is an Authorization protocol, not an Authentication one.
  * The Access Tokens do not represent the user (delegation instead of impersonation).
  * For Authentication plus (OAuth) Authorization, use OpenID Connect.
* The Client App must not be concerned with the content of the Access Token.
  * The Access Token validation & understanding is the duty of only the Protected Resource (with possibly the AS).
  * The CA should only request the Access Token and then pass it on to the PR. It should not attempt to read its content to perform any business logic of ID verification. Therefore it should not break should the Access Token's format or scheme be modified.
* OAuth is a framework, not a standard
  * It does not prescribe the format of the Access Token, or its validation process, so the quality of its actual implementation may vary.

## Glossary

* Authentication = Is someone who they claim they are? Logins & Passwords
* Authorization = Can someone do something? Permissions & Access control
* Client App(lication) = application used by the User that does not necessary require authentication itself but requests access to an API
  * E.g. a public webpage that displays some statistics about a Spotify user account, thus requiring access to parts of that Spotify account, but without needing to login
* Protected Resource = an API the User has access to on its own (e.g. Spotify), and the Client App requests access to.
* User
  * In OAuth, this is the owner of the resource
* Authorization Server = handles authorization requests and is trusted by all partis involved.
  * Must use TLS to guarantee underlying channel security
  * Provides two separated endpoints:
    * A **Authorization endpoint** i.e. a webpage that the CA forwards the User to (with all necessary parameters) to authenticate and come back with a Grant
    * A **Token endpoint** i.e. an API to let the Client Application swap in the Grant for an Access Token
* Scope = permissions to do something within an API.
  * Sent by the Client Application during the initial HTTP Authorization request to the AS.
  * Should be _scoped_ (prefixed) with the API name e.g. `my_api.read` to guarantee namespacing.
* Grant = right of the Client App to perform some actions on the User's behalf, as a random value generated by the AS and only understood by it.
  * Can be implemented in any of a handful of fashions, aka Grant Types, defined by OAuth 2.0 (see below)
  * Typically relatively short-lived (e.g. 1 to 10 minutes).
* Access Token = the "valet key" that allows anyone possessing it to access the Protected Resource with the scopes.
  * This should preferably not be exposed to the user (and her client-side browser) but kept safe in the backend server, although this is not always possible (e.g. client-side-only apps).

## Flow

### General

1. The Client Application makes an Authorization Request to the Authorization Server
  * This request is **not** sent directly from the CA to the AS.
  * Instead, the (Resource Owner) User's browser is redirected to the Authorization Server's **Authorization endpoint** i.e. an actual webpage on a different website, fully away from the Client App.
2. The Authorization Server approves the incoming request, and challenges the User to verify their identity: this is the Authentication part
  * Notice that the User credentials are therefore completely removed from the Client App: it is truly a redirection out of the Client App.
  * The method used for Authentication is left open by the OAuth specification (Login/Password, Google Id, federated entreprise login).
3. Once the User is successfully authenticated, she needs to consent to the permissions requested by the Client App: access this part, edit that part, for how long.
  * This is still fully done outside of the Client App, so no interference are possible
4. The User is redirected back to the Client Application, including an Authorization Grant in the redirection
  * That Grant represents the given right of the Client App to perform some actions on the User's behalf
  * There are a few possible Grant types
  * The Grant is typically short-lived, and to be traded for an Access Token right away.
5. The Client App now armed with a Grant plus some way to identify itself as a valid client (e.g. via client ID & secret), makes a direct background request to the AS.
  * Notice this is the first time the CA communicates directly with the AS (via a background WS API request to the AS' **Token endpoint**)
6. If approved, the AS responds to the Client App's request with an Access Token
  * Only the Client App that was given the Authorization Grant can swap it for a token.
7. The Client App can now use that Access Token to authorize requests to the Protected Resource
  * This is done via the Authorization header, using a given scheme defined by the Authorization Server
    * Using the typical Bearer scheme, anybody whoever has the Access Token can use it
  * What is inside an Access Token, and how the Protected Resource verifies it, is left open
    * Can be a request from the Protected Resource to the AS
    * Or perhaps the PR has an internal mechanism to validate it and understand what permissions were delegated (allowed).
8. Finally, the Client App is allowed access
  * That means it gets the awaited HTTP response from the PR

### [Authorization Code Grant Type](https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type)

Most most common Grant Type.
Best for applications/websites with a backend that can keep a secret i.e. the client secret and Access Token.

1. CA Authorization Request
  * Query Parameters
    * `response_type=code`
    * `client_id={client id}`
    * `redirect_uri={url}`, which must be pre-registered in the AS
    * `scope={scopes}` (optional) = explicitely request permissions (as opposed to a default set of scopes, defined globally or by application or application type)
    * `state={state}` (optional but highly advised, for round-tripping data and CSRF defense)
2. AS Authorization Response
  * Once the AS has authenticated the user and validated the request, it forwards the browser to the *redirect_uri* along with the following **query parameters**:
    * `code` = the Grant value. It has a very short lifetime and can only be used once. The code is bound to the *client_id*, the *redirect_uri*, the Resource Owner and the Scopes the application has been delegated.
    * `state` = same exact *state* value sent in the Authorization request.
  * Alternatively, it can choose to ignore the request and give back no response.
3. CA Token Request
  * The CA can now send a HTTP POST request directly to the AS, to its **Token endpoint**
  * Confidential information (protected by the TLS layer) is passed as POST headers:
    * `Host: {token endpoint url}`
    * `Content-Type: application/x-www-form-urlencoded`
    * `Authorization: Basic {Base64EncodedClientIdAndSecret}` HTTP Basic Authentication header, containing the client ID & secret.
      * Note that Basic Authentication can refer to either RFC7617 (`Base64(client_id + ":" + client_secret)`) or RFC 6749 (`Base64(urlformencode(client_id) + ":" + urlformencode(client_secret))`), which can lead to unexpected 401 unauthorized if we're providing the wrong one to the server.
    * `grant_type=authorization_code` = tells the Token endpoint what we're giving it and what we're trying to achieve
    * `&code={Grant code}`
    * `&redirect_uri={url}`
    * `&client_id={client id}&client_secret={client secret}` = only if didn't use Basic authentication POST header above
4. SA Token Response
  * The SA responds with a HTTP 200 including a JSON body containing the Access Token as well as some meta-information (token type, expiry, and optionally the scope, which is also mandatory if the User didn't consent to all of the requested scopes)
  * This Token must be kept hidden from the User in the Backend, so it cannot fall into the wrong hands.

### Implicit Grant Type

Works for _public clients_ that cannot keep a secret, e.g. runs solely on a client's device or served directly from a CDN with no way of storing client credentials in a way that the User cannot see/access. This also means there cannot be a client secret to pass for the Token Request. Hence it is less secure than the Authorization Code Grant Type.

Since the client cannot keep any predefined secret, there's no added benefit for an additional dedicated Token Request, which is thus removed.
Instead, the Access Token is provided directly via the browser in response to the initial Authorization Request.

1. CA Authorization Request
  * Parameters
    * `response_type=token`
    * `client_id` = more informative than anything
    * `redirect_uri` = this pre-registered URL is the main defense mechanism of this Grant Type. It must match exactly (no wildcards allowed).
    * `scope`
    * `state`
2. SA Authorization Response
  * After the Authentication, the Access Token is returned now as a URL _hash fragment #parameter_ to be retrieved and stored in the User's browser's local storage.
  * This means the Access Token is exposed to the Resource Owner. It may not look serious, as the Resource Owner is supposed to have access to the resources she gave access to, but it also means that it is readable to anyone with access to the user's browser. It also makes 3rd party JavaScript a potential threat.
  * Also, there's no way to verify that the Client App was the intended recipient of this Access Token (since there is no client secret), as it may have been injected.
  * Despite its flaws, OpenID Connect can make this flow more secure.